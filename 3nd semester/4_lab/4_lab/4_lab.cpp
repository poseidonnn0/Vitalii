#include <iostream>
#include <cstdlib>
#include <vector>
#include <ctime>
/* №4 Сортировка методом прочесывания */

/* Суть:  
Первоначальный разрыв между сравниваемыми элементами лучше брать не абы какой, а с учётом специальной величины называемой фактором уменьшения, оптимальное значение которой равно примерно 1.2473309. 
Сначала расстояние между элементами равно размеру массива разделённого на фактор уменьшения (результат, естественно, округляется до ближайшего целого). 
Затем, пройдя массив с этим шагом, мы снова делим шаг на фактор уменьшения и проходим по списку вновь. 
Так продолжается до тех пор, пока разность индексов не достигнет единицы. В этом случае массив досортировывается обычным пузырьком.
*/

void combSort(std::vector<int>& array)
{
	int gap = array.size();
	bool flag = true;

	while (gap != 1 || flag == true)
	{
		gap = (gap) / 1.3; // фактор уменьшения, который вычисляется данным способом, но можно и напрямую использовать 1.247
		if (gap < 1)
			gap = 1;
		flag = false;

		for (int i = 0; i < array.size() - gap; i++)
		{
			if (array[i] > array[i + gap])
			{
				std::swap(array[i], array[i + gap]);
				flag = true;
			}
		}
	}
}
// В лучшем случае асимптотика равна O(nlog(n)), в худшем – O(n2).
int main()
{
	srand(static_cast <unsigned int> (time(0))); // Время сис. часов(где компилируют)
	setlocale(LC_ALL, "RUS");
	int N;
	std::vector <int> mas;
	std::cout << "Введите число рандомных чисел в массиве = ";
	std::cin >> N;
	for (int i = 0; i < N; i++)
	{
		mas.push_back(rand());
	}
	std::cout << "\nМассив чисел без сортировки:\n";
	for (int i = 0; i < mas.size(); i++)
	{
		std::cout << mas[i] << " ";
	}
	std::cout << "\nМассив чисел после сортировки:\n";
	combSort(mas);
	for (int i = 0; i < mas.size(); i++)
	{
		std::cout << mas[i] << " ";
	}
}
